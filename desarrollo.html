<!DOCTYPE html>
<html lang="es">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="Author" content="Barrios Aguilar Dulce Michelle" /><!--Autor-->

    <!-- Título de tu proyecto -->
    <title>Estudio general del sistema</title>

    <meta name="Description" content="Estudio General del Sistema" /><!--Descripción del tutorial-->
    <meta name="Keywords" content="Factores, Estudio, General, Sistema" /><!--Palabras clave-->
    <meta name="robots" content="noindex, nofollow" />

    <script src="media/js/jq.js" type="text/javascript"></script>
    <script src="media/js/m.js" type="text/javascript"></script>
    <script src="media/js/ui.js" type="text/javascript"></script>

    <link rel="stylesheet" href="media/css/ui.css" type="text/css" />

    <!-- El siguiente CSS puede utilizarse para hacer los ajustes necesarios de los contenidos -->
    <link rel="stylesheet" href="media/css/intro.css" type="text/css" />

</head>

<body>

    <div align="justify">
    <h1>Sistemas Algebraicos</h1>
    
    <h5>
            <p>
                Un sistema algebraico es una estructura matemática que consiste en un conjunto no vacío A dotado de un conjunto de operaciones F que combinan elementos de A para formar otros elementos de A.
                Dicho de otra manera, un sistema algebraico es un conjunto no vacío que es cerrado respecto a una o más operaciones. </p>
            <p>
                Los sistemas algebraicos son conjuntos de dos o más ecuaciones con más de una incógnita que conforman un problema matemático que consiste en encontrar la solución, dando así,
                valores a las incógnitas las cuales satisfacen dichas operaciones. Estas incógnitas son representadas cotidianamente por las últimas letras del alfabeto latino o, en caso de ser demasiadas,
                con subíndices.</p>
        </div>
    </h5>
    
    <div align="justify">
    <h1>Operaciones</h1>
    <h5>
            <p>
                Es una función que asigna uno o más elementos de A a un único elemento de A.
                Para el estudio de sistemas algebraicos, el lector ya se encuentra familiarizado con las operaciones de suma y multiplicación de números.
                Estas operaciones se denotan como:
            </p>
            <p>a + b = c, a*b = c</p>
            <p>
                Ahora que sabemos más acerca de los sistemas algebraicos, podemos pasar a hablar acerca de las propiedades
                que estos deben de cumplir.
            </p>

        </div>
    </h5>
    
    <section>
        <div align="justify">
        <p><b>
                <h5>PROPIEDADES DE LOS SISTEMAS ALGEBRAICOS</h5>
            </b></p>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Cerradura.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Asociativa.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Identidad.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Inverso.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Distributiva.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Conmutativa.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Cancelación.</h5>
            <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Idempotencia.</h5>
            
        </div>
    </section>
    <h5>
        <div align="justify">
            <p><b>CERRADURA</b></p>
            <p>
                INFO
            </p>
            <p><b>ASOCIATIVA</b></p>
            <p>
                Se dice que una operación ∗ en un conjunto S es asociativa o que satisface la ley asociativa si, para elementos arbitrarios a, b y c en S, se tiene:
            </p>
            <p>(a ∗ b) ∗ c = a ∗ (b ∗ c)</p>
            <p>Ejemplo: (2+3)+4 = 2+(3+4)</p>
            <p>
                Esta propiedad se aplica a dos tipos de operaciones: la suma y la multiplicación, esta propiedad indica que cuando existen tres o más cifras en estas operaciones, el resultado no depende de la manera en la que se agrupan los términos.   
            </p>
            <p><b>IDENTIDAD</b></p>
            <p>
                Considere una operación ∗ en un conjunto S. Un elemento e en S se denomina elemento identidad para ∗ si, para cualquier elemento a en S, a:
            </p>
            <p>a * e = e * a = a</p>
            <p>
                En términos más generales, un elemento e se denomina identidad izquierda o identidad derecha según sea el caso.
            </p>
            <p><b>INVERSO</b></p>
            <p>
                Suponga que una operación ∗ en un conjunto S tiene un elemento identidad e. El inverso de un elemento a en S es un elemento b tal que:
            </p>
            <p>a * b = b * a = e</p>
            <p>
                El elemento inverso se conoce como el concepto del inverso de un número con signo.
            </p>
            <p><b>DISTRIBUTIVA</b></p>
            <p>
                INFO
            </p>
            <p><b>CONMUTATIVA</b></p>
            <p>
                Se dice que una operación ∗ en un conjunto S es conmutativa o que satisface la ley conmutativa si, para elementos arbitrarios a y b en S,
            </p>
            <p>a ∗ b = b ∗ a</p>
            <p><b>CANCELACIÓN</b></p>
            <p>
                Se dice que una operación ∗ en un conjunto S satisface la ley de cancelación izquierda o la ley de cancelación derecha según sea el caso:
            </p>
            <p>a ∗ b = a ∗ c implica b = c   ó  b ∗ a = c ∗ a implica b = c</p>
            <p>contrario o el recíproco para la suma y multiplicación respectivamente.</p>
            <p>
                Para la suma y multiplicación, todo número sumado con su inverso se “cancela” y todo número multiplicado con su inverso se “cancela”.
            </p>
            <p><b>IDEMPOTENCIA</b></p>
            <p>
                INFO
            </p>

        </div>
    </h5>
    
    <h1>Álgebra Booleana</h1>
    <h5>
        <div align="justify">
            <p>El álgebra booleana, o también conocida como álgebra de Boole, es un sistema algebraico basado en la
                lógica proposicional, utilizado para representar circuitos lógicos en forma de ecuaciones. Apoyándose a su vez,
                de la lógica binaria y la teoría de conjuntos. Fue desarrollada por el matemático y lógico británico George
                Boole durante el siglo XIX.
            </p>
            <p>Como ya se mencionó, en este sistema algebraico de base binaria, nos indica que se van a manipular
                valores binarios, esto nos dice que son valores que pueden ser verdaderos (1) o falsos (0). Y al ser un sistema
                algebraico, se van a estipular ciertos reglamentos para su adecuado y lógico uso, utilizando operaciones
                como conjunción (AND), disyunción (OR) y la negación (NOT). Nos permite evaluar condiciones, tomar decisiones
                y controlar el flujo de ejecución de programas que queramos poner en marcha.</p>
        </div>
    </h5>
    <section>
        <div align="justify">
        <p><b>
                <h5>DEL ÁLGEBRA DE BOOLE:</h5>
            </b> </p>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Diseño de circuitos lógicos (digitales: procesadores, memorias y dispositivos lógicos programables).</h5>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Programación y algoritmos (estructuras de control condicional).</h5>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Diseño de hardware.</h5>

    </section>

    <section>
        <div align="justify">

        <p><b>
                <h5>NOS PERMITE:</h5>
            </b> </p>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Debido a sus leyes, simplificar expresiones booleanas complejas, facilitando su comprensión y
            análisis.
            (Como lo hemos visto en los distintos métodos de minimización, y ahora con Quine-McCluskey).</h5>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Optimizar circuitos digitales. (Se reducen el número de compuertas lógicas, mejorando su eficacia.)</h5>
    </section>
    
    <h5>
        <div align="justify">
            <p>Y proporciona un marco matemático adecuado para el estudio de la lógica y el razonamiento lógico; asunto
                vital
                para la computación moderna.</p>

        </div>
    </h5>
    
    <h1>Leyes</h1>

    <section>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Ley Conmutativa</h5>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Para la operación disyuntiva (OR) nos dice que el orden que ocupen las variables es indiferente. Lo
            representamos como: &or;</p>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Ley Asociativa</h5>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Para la operación conjuntiva (AND) el orden que ocupen las variables es indiferente, Lo representamos
            como:
            &and;</p>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Ley Distributiva</h5>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Para la operación disyuntiva (OR), en su resultado al tener un caso en que intervienen más de dos
            variables, va a ser independiente del modo en que se agrupen las variables.</p>
    </section>
    
    <h1>Métodos de minimización</h1>
    <h5>
        <div align="justify">
            <p>Ahora estamos teniendo un enfoque centrado a la búsqueda de representaciones algebraicas de lógica
                para
                representar desde circuitos hasta estructuras condicionales que por ende nos deja en un entorno de
                lógica con razón de dos respuestas en las que encontramos a verdadero (1) y falso (0). Por lo que 
                encontraremos sistemas algebraicos en los que tendremos expresiones extensas y que complicarían la 
                comprensión de sí mismas para uno.
                Por lo tanto, nos quedamos en la necesidad de recurrir a métodos que logren reducir las expresiones
                en álgebra de Boole, que ahora; por comodidad, vamos a llamar funciones booleanas.</p>
            <p>Para nuestro curso hemos visto distintas formas de reducir una función booleana, siendo estas las más
                destacadas de las que se encuentran en el entorno computacional, en el área de lógica se refiere,
                las
                cuales
                serían reducciones por:
            </p>
        </div>
    </h5>
    <section>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Método algebraico.</h5>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Mapas de Karnaugh.</h5>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• Método de Quine-McCluskey</h5>
    </section>
    <section>
        <h2>Método Algebraico</h2>
        <h5>
            <div align="justify">
                <p>Para este método es a primera instancia, fácil de interpretar por su semejanza con los sistemas
                    algebraicos a
                    los que estamos acostumbrados. Sin embargo, aquí iremos aplicando los postulados (o propiedades)
                    del álgebra
                    de Boole. </p>
                <p>Bueno, las propiedades que se estuvieron manejando durante el curso para la aplicación de este
                    método se
                    encuentran en la tabla VI que adjuntamos a continuación, en donde estamos manejando las
                    representaciones de la
                    conjunción, disyunción y negación en su forma ( · , + y ‘, respectivamente).</p>
                <img id="t1" src="images/t1.png" alt="Descripción de la imagen">
                <p></p>
                <p>Tabla de propiedades del método algebraico basado en las tablas de lógica proposicional proporcionadas por el profesor
                    Ing. Orlando Zaldívar Zamorategui. </p>
            </div>
        </h5>
    </section>
    
    <section>
        <h2>Mapas de Karnaugh</h2>
        <h5>
            <div align="justify">
                <p>Este método surge de tratar de agrupar a los términos de interés sin aplicar de forma directa el
                    desarrollo
                    algebraico que ofrece el método anterior. Y esto se constituye de desarrollar de forma gráfica
                    la tabla de
                    verdad de una función lógica. </p>

                <p><p><p></p><img id="t2" src="images/MapaKarnaugh_Chico.png" alt="Descripción de la imagen"><p>
                    <div align='center'>
                    <h8>Mapa de Karnaugh trabajado en clase del profesor Ing. Orlando Zaldívar Zamorategui.</h8>
                    </div>
                    <p><p><p></p>
                    
                <p>Como podemos ver, se pueden tratar funciones de dos hasta cinco variables, para este método
                    tabular cuyos
                    términos canónicos adyacentes pueden ser agrupados para hacer de forma más sencilla la
                    agrupación de los
                    elementos.</p>
                <p>Su algoritmo, en pocas palabras, consiste en:</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. Se escribe un 1 en los cuadros que tiene un número de los que forman la 
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sumatoria de la función.</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Se forman los grupos de minitérminos que se consideran vecinos (tienen un
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lado en común).</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. Se identifican a las variables para los conjuntos hechos por los grupos que
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hicimos de los minitérminos, estos serán los conjuntos.</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. Hacemos la sumatoria de los productos *Habrá que comprobar el resultado
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;con el método gráfico de formar líneas dictadas por las variables que forman a
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;los productos de los grupos*.</p>
                    
                <p><p></p>
                 <img id="t2" src="images/Ejemplo_MapasKarnaugh.png" alt="Descripción de la imagen">
                 <div align='center'>
                    <h8><p></p>Ejercicio aplicando Mapas de Karnaugh trabajado en clase del profesor Ing. Orlando Zaldívar Zamorategui.</h8>
                </div>
                
    </section>
    
    <section>
        <h2> Método de minimización de Quine-McCluskey</h2>
        <h5>
            <div align="justify">
                <p>Fue desarrollado por Willard Van Orman Quine y Edward J. McCluskey. El Algoritmo Quine–McCluskey es un método tabular que se utiliza para 
                    minimizar funciones booleanas siguiendo un algoritmo, similar a la utilización del mapa de Karnaugh. La ventaja que tiene sobre los mapas 
                    de Karnaugh es que podemos utilizar cuantas variables queramos, puesto que, el método evita que hagamos demasiados mapas de Karnaugh. Cabe 
                    mencionar que este método resulta tener mayor eficacia en cuanto a su implementación en el lenguaje computacional. 
                    El metodo de Quine-McCluskey permite un manejo amplio en las funciones booleanas, pudiendo manejar casos con:
                    
                </p>

                <img src="images/WillardVanOrmanQuine.jpeg" width="200" height="280px" alt="Uni&oacute;n">
                <div align='center'>
                    <p><p>Willard Van Orman Quine (1908-2000)</p>
                </div>

		        <p></p><img src="images/EdwardJMcCluskey.jpeg" width="300" height="451px" alt="Uni&oacute;n">
                <div align='center'>
                    <p><p>Edward J. McCluskey (1929-2016)<p></p>
                </div>                
                

                <p>A considerar que la función booleana como: </p>
                <img id="t2" src="images/FuncionBooleanaPartes.png" alt="Descripción de la imagen">
                <p>Se nos puede presentar una función booleana de:</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  - 2 variables: f(a,b)</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  - 3 variables: f(a,b,c)</p>
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  - 4 variables: f(a,b,c,d)</p>
                <p> O hasta 7 variables: f(a,b,c,d,e,f,g)</p>
                <p>Y eso nos va a indicar que las representaciones binarias de los minitérminos podrían llegar a
                    representarse dependiendo de la cantidad de variables presentes en la función boolena:</p>
                <img id="t2" src="images/tablaMiniterminos.png" alt="Descripción de la imagen">
                <p><p></p>Y así sucesivamente.</p>
                <p>Entonces, para su desarrollo se realiza por medio de la elaboración de tablas en las que se
                    van a ir agregando datos específicos, así que, para minimizar una función booleana se podría
                    resumir en:</p>


                <h3><b><p><p></p>PASO 1. </b></h3>
                <p>Elaborar una tabla 1 en donde vamos a ir almacenando a los minitérminos de la función en la
                    primera columna, su representación binaria en la tercera columna, y por último la segunda
                    columna la cantidad de 1’s en su representación binaria (0, 1, 2, 3, …, n).</p>
                <img id="t2" src="images/qm_3.png" alt="Descripción de la imagen">
                <p><b>
                        *NOTA: la cuarta columna sirve de apoyo para agregar comentarios al momento de ejercer algún
                        movimiento importante en el desarrollo y es necesario volver a checar qué se hizo. Aunque,
                        nosotros lo hemos trabajado como una columna para escribir una marca de tipo *, que vamos a
                        explicar en un momento.
                    </b> </p>


                <h3><b><p><p></p>PASO 2. </b></h3>
                <p>Generamos una tabla 2, en esta vamos a reordenar a los minitérminos y su representación de
                    acuerdo con la cantidad de 1’s que tienen en su representación. </p>
                <img id="t2" src="images/qm_4.png" alt="Descripción de la imagen">
                <p>Y vamos marcando con un * en la tabla 1, a los minitérminos que ya hemos agregado a la tabla 2.
                </p>
                <img src="images/qm_5.png" alt="qm5">


                <h3><b><p><p></p>PASO 3. </b></h3>
                <p>Generamos una tabla 3, que nos servirá para empezar a realizar combinaciones. Efecto que puede
                    ser presentado una vez que se pase por los siguientes puntos:</p>

                <section>
                    <h6>

                        <p> I. Buscamos en la representación binaria de los minitérminos, 
                            <br>los que difieren en solo una variable (la que sea) para
                            <br>poder realizar una combinación con apoyo en la tabla 2. </p>
                        <p> II. Empezamos con el primer caso en la cantidad de 1’s con 
                            <br>la siguiente cantidad. En este caso los que tienen cero
                            <br>1’s con los que tiene un solo 1. </p>
                        <p> III. Al combinar a los minitérminos, si tenemos:
                        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  0 y 0 escribimos 0</p>
                        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1 y 1 escribimos 1</p>
                        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  0 y 1 escribimos - </p>
                    </h6>
                </section>
                <img src="images/qm_6.png" alt="">
                <p><p>Y vamos marcando en la tabla 2 a los minitérminos que vamos combinando.</p>
                <img src="images/qm_7.png" alt="">

                <p><b><p></p>NOTA: Puede haber casos en los que nos quede un minitérmino que no se pueda combinar con los
                        otros que están involucrados en la función booleana. Estos ya son considerados implicantes primos 
                        y van directo a la tabla del mismo nombre.</b></p>


                <h3><b><p><p></p>PASO 4. </b></h3>
                <p>Generamos una tabla 4, para realizar una segunda combinación; sin embargo, serán
                    combinaciones de combinaciones, apoyándonos en la tabla anterior (la tabla 3).</p>
                <p>Para esta segunda vuelta de combinaciones, nos seguimos basando en las reglas de combinación que
                    hemos descrito anteriormente.</p>
                <img src="images/qm_8.png" alt="">
                <img src="images/qm_9.png" alt="">
                <p><p></p>Para la combinación de combinaciones vamos a considerar que sólo una variable difiera entre las 
                representaciones binarias de las combinaciones. Por ejemplo: (0,1) combinado con (2,3) cuyas representaciones 
                son 000- y 001- respectivamente, y la única variable que difiere es ‘c’ por lo tanto, se pueden combinar estas 
                combinaciones.</p>

                <p>Y así, la primera combinación de combinaciones generada sería (0,1,2,3), cuya representación en la columna abcd 
                queda como: 00--.</p>
                
                <p>Marcamos un * en la última columna indicando qué combinaciones han logrado pasar por una segunda combinación.</p>
                
                <p>En caso de tener otras combinaciones que al combinarse generen una combinación igual a una ya obtenida, se van 
                a marcar también. En este caso, con las combinaciones (0,2) y (1,3) podemos marcarlas también debido a que al 
                combinarlas obtenemos (0,1,2,3), con una representación exactamente igual: 00-- como con la combinación anterior.</p>
                </p>

                <h3><b><p><p></p>PASO 5. </b></h3>
                <p>Generamos la tabla 5 (la tabla de los implicantes primos), y vamos almacenando a los
                    minitérminos y combinaciones que hemos considerado como implicantes primos, además de sus
                    representaciones binarias en su correspondiente columna y marcar con una X en las celdas que
                    denotan un minitérmino de la función.</p>
                
                <p>Y consideramos para la escritura del producto:</p>
                <p><b>Si en la representación binaria (abcd) tenemos para el producto:
                        <section>
                            <h6>
                                <p> - no hay variable representativa</p>
                                <p> 0 la variable está negada</p>
                                <p> 1 la variable no está negada</p>
                            </h6>
                        </section>
                    </b></p>
                <p>TABLA DE LOS IMPLICANTES PRIMOS: </p>
                <img src="images/qm_10.png" alt="">
                <h3><b><p><p></p>PASO 6. </b></h3>
                <p>Y escribimos el resultado como la suma de productos (aunque esta no es la única forma).</p>
                <img src="images/qm_11.png" alt="">
            </div>
        </h5>
    </section>



</body>

</html>